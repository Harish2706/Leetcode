//lazyyy propgation(Rangesum and increase in val for l and r)
//it is like creating a second tree for later prop
#include <bits/stdc++.h>
using namespace std;
//Traverse in segtree when previous lazy is there update it first
//complete overlap = update the node and lazyyy propgationd down
//paritally overlap = left and right node = left + right
//no overlap = return

class segtree{
    vector<int>seg,lazy;
    public:
      segtree(int n){
          seg.resize(4*n);
          lazy.resize(4*n,0);
      }
    public:
       void build(int ind,int low,int high,vector<int>&arr){
           if(low == high){
               seg[ind] = arr[low];
               return;
           }
           int mid = (low + high) >> 1;
           build(2*ind+1,low,mid,arr);
           build(2*ind+2,mid+1,high,arr);
           seg[ind] = seg[2*ind+1] + seg[2*ind+2];
       }
     
    public:
       void update(int ind,int low,int high,int l,int r,int val){
           //update the previous remaining updates
           //and propgate downwards
           if(lazy[ind]!=0){
               seg[ind] += (high - low + 1) *lazy[ind];
               //propgate the lazy update downwards
               //for the remaining nodes to get updated
               if(low!=high){
                   lazy[2*ind+1] +=lazy[ind];
                   lazy[2*ind+2] += lazy[ind];
               }
               lazy[ind] = 0;
           }
           //no overlap
           //we dont do anything and return
           if(high<l || r<low){
               return;
           }
           
           //complete overlap
           //l low high r
           if(low>=l && high<=r){
               seg[ind] += (high - low +1 ) * val;
              // if NOT a leaf node, propagate to children

               if(low!=high){
                   lazy[2*ind+1] += val;
                   lazy[2*ind+2] += val;
               }
               return;
           }
           // last case has to be no overlap case
           int mid = (low + high) >> 1;
           update(2*ind + 1,low,mid,l,r,val);
           update(2*ind + 2,mid + 1,high,l,r,val);
           seg[ind] = seg[2*ind + 1] + seg[2*ind + 2];

       }
       public:
       int query(int ind,int low,int high,int l,int r){
           //update f any updates are remaining
           //as the node will stay fresh and updated
             if(lazy[ind]!=0){
               seg[ind] += (high - low + 1) *lazy[ind];
               //propgate the lazy update downwards
               //for the remaining nodes to get updated
               if(low!=high){
                   lazy[2*ind+1] +=lazy[ind];
                   lazy[2*ind+2] += lazy[ind];
               }
               lazy[ind] = 0;
           }
           
           //no overlap return 0
           if(high<l || r<low){
               return 0;
           }
           //complete overlap
           if(low>=l  && high<=r) return seg[ind];
           int mid = (low + high ) >> 1;
           int left = query(2*ind + 1,low,mid,l,r);
           int right = query(2*ind+2,mid + 1,high,l,r);
           return left + right;
       }
};
int main() {
   

}
